(* Sahil Yadav *)

(* #1 - quicksort *)
(*
	Parition(aList,pivot): 
		Return a nil tuple if the aList is null irregardles of the pivot.
		Returns two sublist in which one is below the pivot value and other is above pivot value. The two sublist are generated by recursively calling parition with rest of the 
			list and the pivot value.
  	Quicksort(aList): 
		Returns nil if aList is null or [].
		Returns a sorted list by concatening first between the two sorted sublist after partition return the two sublist.
  	Signature:
  		val partition = fn : int list * int -> int list * int list
	  	val quicksort = fn : int list -> int list
*)

fun partition(nil,_) = (nil,nil) |
	partition(first::rest,pivot) = 
	let 
		val (below,above) = partition(rest,pivot)
	in 
		if first <= pivot then (first::below,above) 
		else (below,first::above)
end;

fun quicksort nil:int list = nil | 
	quicksort (first::rest) = 
	let
		val (below,above) = partition(rest,first)
	in
		quicksort(below)@[first]@quicksort(above)
	end;

(* #2 - member*)
(*
	Member(Value, aList): 
		Passes in the value to lookup and breaks down the aList into the first element and a list without the first element.
		Then we recursively call member by passing in the lookup value and the rest of the list without the first value until
		the list is fully travered and value is not found or the value is found.
		Returns True: If the value is an element of the List.
		Returns False: If we pass in nil or empty list ([]) and a value or if the value is not in the list.
*)

fun member (_,nil) = false |
	member (e,first::rest) =
	e = first 
	orelse 
	member(e,rest);         
               
(* #3 - returns the union of sets (lists) s1 and s2*)
(* 
	union(s1,s2):
		Return s1 if s2 is nil because s1 union [] = s1.
		Return s2 if s1 is nil because [] union s2 = s2.
		Breaks the list into first and rest and then checks to see if the first is a member:
			If yes, then recursively call union with the rest of the s1 list and s2.
			If no, then concat first to a list while recursively calling union with rest and s2 until the s1 is full tracversed. After travesal, quicksort the sort.
		Signature:
			val union = fn : int list * int list -> int list
*)

fun union(nil,s2) = s2 |
	union(s1,nil) = s1 | 
	union(first::rest,s2) =
	if member(first,s2) then union(rest,s2)
	else quicksort(first::union(rest,s2));

(* #4 - returns the intersection of sets (lists) s1 and s2 *)
(*
	intersection(s1,s2): 
		Return nil if s2 is nil because a [] list does not have any common element with any list except [].
		Return nil if s1 is nil because a [] list does not have any common element with any list except [].
		Breaks the list into first and rest and then checks to see if the first is a member:
			If yes, then concat first to a list while recursively calling union with rest and s2 until the s1 is full tracversed. After travesal, quicksort the sort. 
			If no, then recursively call intersect with the rest of the s1 list and s2.
		Signature:
			val intersection = fn : int list * int list -> int list
*)

fun intersection(nil,s2) = nil |
   intersection(s1,nil) = nil |
   intersection(first::rest,s2) =
   if member(first,s2) then quicksort(first::intersection(rest,s2))
   else intersection(rest,s2);

(* #5 - Return list of integers from start (inclusive) to stop (exclusive) by step 
Write- a function to construe! the intersection of two sets.*)
(* 
	helperRange(start,stop,step):
		Condition to check continue or stop:
			Return true if (ascending list) start < stop and step > 0 or (descending list) start<stop and step <0. Also because Start is in range.
			Returns false if start>stop and step>0 because the start will be out of range or start<stop and step <0 becasue stop will be out of range.
	range(start,stop,step): 
		Returns a nil list if start and stop are both same.
		Return a list with start inclusive and stop exclusive by checking continue condition in helperRange and then concatening start and recursively calling range with start
			as start+step until start is bigger than stop.
		Returns a [] because contiue statement returns false.
	Signature:
		val helperRange = fn : int * int * int -> bool
		val range = fn : int * int * int -> int list
*)

fun helperRange(start,stop,step) =
	if start < stop andalso step > 0 then true 
	else if start > stop andalso step < 0 then true
	else false; 
fun range(start,stop,step) = 
	if start = stop then nil
	else if helperRange(start,stop,step) then [start]@range(start+step,stop,step)
	else [] ;

(* #6 - Return a slice of a list between indices start inclusive, and stop exclusive. Assume first element of list is at index 0*)
(*
	helperStart(aList,start):
		Returns aList if start = 0. 
		Return the aList after the start value by breaking down the list into first & rest and recursively calling the function on rest until start reaches to 0.
  	heleperStop(aList,stop):
  		Returns a empty list if stop value is 0. 
		Return the aList before the stop value by breaking down the list into first & rest and recursively calling the function on rest until stop reaches to 0.
  	slice(aList,start,stop):
  		Return the instersected list of helperStart and helperStop because that will have the common element in both.
	Signatures:
	  	val helperStart = fn : 'a list * int -> 'a list
  		val helperStop = fn : 'a list * int -> 'a list
  		val slice = fn : int list * int * int -> int list
*)

fun helperStart (aList,0) = aList |
	helperStart(first::rest,start) = helperStart(rest, start-1);
fun helperStop(aList,0) = [] |
	helperStop(first::rest,stop) = first::helperStop(rest, stop - 1);
fun slice(_, 0,0) = nil | 
	slice(aList,start,stop) = intersection((helperStart(aList,start),helperStop(aList,stop)));